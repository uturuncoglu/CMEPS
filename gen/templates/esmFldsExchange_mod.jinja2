module esmFldsExchange_{{ app }}_mod
  !---------------------------------------------------------------------
  ! ATTENTION:
  !
  ! This file is auto-generated and should not be manually edited
  ! Please use application specific YAML file and parser in the gen/
  ! directory to update content of the file.
  !---------------------------------------------------------------------

  !---------------------------------------------------------------------
  ! This is a mediator specific routine that determines ALL possible
  ! fields exchanged between components and their associated routing,
  ! mapping and merging
  !---------------------------------------------------------------------

  implicit none
  public

  public :: esmFldsExchange_{{ app }}

  character(*), parameter :: u_FILE_u = &
       __FILE__

!===============================================================================
contains
!===============================================================================

  subroutine esmFldsExchange_{{ app }}(gcomp, phase, rc)

    use ESMF
    use NUOPC
    use med_kind_mod          , only : CX=>SHR_KIND_CX, CS=>SHR_KIND_CS
    use med_kind_mod          , only : CL=>SHR_KIND_CL, R8=>SHR_KIND_R8
    use med_utils_mod         , only : chkerr => med_utils_chkerr
    use esmFlds               , only : med_fldList_type
    use esmFlds               , only : addfld => med_fldList_AddFld
    use esmFlds               , only : addmap => med_fldList_AddMap
    use esmFlds               , only : addmrg => med_fldList_AddMrg
    {% for comp in comps %}
    use esmflds               , only : comp{{ comp }}
    {% endfor %}
    {% for map_type in map_types %}
    use esmflds               , only : map{{ map_type }}
    {% endfor %}
    use esmflds               , only : ncomps, coupling_mode, mapnames
    use esmflds               , only : fldListTo, fldListFr
    use esmflds               , only : fldListMed_aoflux, fldListMed_ocnalb
    use med_internalstate_mod , only : mastertask, logunit

    ! input/output parameters:
    type(ESMF_GridComp)              :: gcomp
    character(len=*) , intent(in)    :: phase
    integer          , intent(inout) :: rc

    ! local variables:
    integer             :: i, n, maptype
    character(len=CX)   :: msgString
    character(len=CL)   :: cvalue
    character(len=CS), allocatable :: flds1(:)
    character(len=CS), allocatable :: flds2(:,:)
    character(len=*) , parameter   :: subname='(esmFldsExchange_{{ app }})'
    !--------------------------------------

    call ESMF_LogWrite(trim(subname)//": called", ESMF_LOGMSG_INFO)
    rc = ESMF_SUCCESS

    !=====================================================================
    ! Scalar information
    !=====================================================================

    call NUOPC_CompAttributeGet(gcomp, name="ScalarFieldName", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    do n = 1,ncomps
       call addfld(fldListFr(n)%flds, trim(cvalue))
       call addfld(fldListTo(n)%flds, trim(cvalue))
    end do

    {# loop over target components #}
    {% for comp in target_comps %}
    !=====================================================================
    ! FIELDS TO {{ comp | upper }}
    !=====================================================================
    {% for k1, v1 in mapping.items() %}
    {# check current component is same with target component #}
    {% if k1[0] == comp %}
    {# get number of field in the field group and use it in allocate statement #}
    {% set nfields = v1 | length %}
    {% set len = 10 %}
    {# create 2d array for field list if source and destination field names are different #}
    {% if k1[6] == False %}
    allocate(flds2({{ nfields }},2))
    {# create list of fileds in the same group #}
    {# loop over field group and create field list #}
    {% for f in v1 %}
    flds2({{ loop.index }},:) = (/ '{{ f[1] | str_format(len) }}', '{{ f[3] | str_format(len) }}' /)
    {% endfor %}
    {# create 1d array for field list if source and destination field names are same #}
    {% else %}
    allocate(flds1({{ nfields }}))
    {# create list of fileds in the same group #}
    {% if nfields == 1 %}
    flds1 = (/ '{{ v1[0][1] | str_format(len) }}' /)
    {% else %}
    {# loop over field group and create field list #}
    {% for f in v1 %}
    {% if loop.index == 1 %}
    flds1 = (/ '{{ f[1] | str_format(len) }}', &
    {% elif loop.index < loop.length %}
               '{{ f[1] | str_format(len) }}', &
    {% else %}
               '{{ f[1] | str_format(len) }}' /)
    {% endif %}
    {% endfor %}
    {% endif %}
    {% endif %}
    {# add code to add fields, define mapping and merging #}
    {% if k1[6] == False %}
    {% set src_fld = 'trim(flds2(n,1))' %}
    {% set dst_fld = 'trim(flds2(n,2))' %}
    {% set num_fld = 'size(flds2(:,1))' %}
    {% else %}
    {% set src_fld = 'trim(flds1(n))' %}
    {% set dst_fld = 'trim(flds1(n))' %}
    {% set num_fld = 'size(flds1)' %}
    {% endif %}
    do n = 1, {{ num_fld }}
       {% if v1[0][0] !=  'med' %}
       call addfld(fldListFr(comp{{ v1[0][0] }})%flds, {{ src_fld }})
       {% endif %}
       {# add mapping if map type is not 'unset' #}
       {% if v1[0][2] !=  'med' %}
       call addfld(fldListTo(comp{{ v1[0][2] }})%flds, {{ dst_fld }})
       {% endif %}
       {% if v1[0][4] !=  'unset' %}
       call addmap(fldListFr(comp{{ v1[0][0] }})%flds, {{ src_fld }}, comp{{ v1[0][2] }}, map{{ v1[0][4] }}, '{{ v1[0][5] }}', '{{ v1[0][6] }}')
       {% endif %}
       {# add merging if merge type is not 'unset' #}
       {% if k1[4] !=  'unset' %}
       {% if k1[5] ==  'unset' %}
       call addmrg(fldListTo(comp{{ v1[0][2] }})%flds, {{ src_fld }}, mrg_from=comp{{ v1[0][0] }}, mrg_fld={{ dst_fld }}, mrg_type='{{ k1[4] }}')
       {% else %}
       call addmrg(fldListTo(comp{{ v1[0][2] }})%flds, {{ src_fld }}, mrg_from=comp{{ v1[0][0] }}, mrg_fld={{ dst_fld }}, mrg_type='{{ k1[4] }}', mrg_fracname='{{ k1[5] }}')
       {% endif %}
       {% endif %}
    end do
    {% if k1[6] == False %}
    deallocate(flds2)
    {% else %}
    deallocate(flds1)
    {% endif %}

    {% endif %}
    {% endfor %}
    {% endfor -%}

    {{ '    ' }}call ESMF_LogWrite(trim(subname)//": done", ESMF_LOGMSG_INFO)

  end subroutine esmFldsExchange_{{ app }}

end module esmFldsExchange_{{ app }}_mod
